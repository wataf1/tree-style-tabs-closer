// This Source Code Form is subject to the terms of the Mozilla Public
// license, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//alias (\| "[^"]+")\s*(:?\n)\s*
interface EvListener<T extends Function> {
    addListener: (callback: T) => void;
    removeListener: (listener: T) => void;
    hasListener: (listener: T) => boolean;
}
type Listener<T> = EvListener<(arg: T) => void>;

//<editor-fold desc="Tree Style Tabs">
//<editor-fold desc="Types">
type TstId = "treestyletab@piro.sakura.ne.jp"
declare const kTST_ID: TstId;
type OnClickData = {
    menuItemId: number | string;
    modifiers: string[];
    editable: boolean;
    parentMenuItemId?: number | string;
    mediaType?: string;
    linkUrl?: string;
    srcUrl?: string;
    pageUrl?: string;
    frameUrl?: string;
    selectionText?: string;
    wasChecked?: boolean;
    checked?: boolean;
};
type ContextMenuOnClickedFunction = (info: OnClickData, tab: ChromeTab) => void;
type ContextType = | "all" | "page" | "frame" | "page" | "link" | "editable" | "image"
    | "selection" | "video" | "audio" | "launcher" | "browser_action" | "page_action"
    | "password" | "tab";
type ItemType = "normal" | "checkbox" | "radio" | "separator";

interface Properties {
    type?: ItemType;
    id?: string
    title?: string;
    checked?: boolean;
    command?: | "_execute_browser_action" | "_execute_page_action" | "_execute_sidebar_action";
    contexts?: ContextType[];
    onclick?: (info: OnClickData, tab: ChromeTab) => void;
    parentId?: number | string;
    documentUrlPatterns?: string[];
    targetUrlPatterns?: string[];
    enabled?: boolean;
}

type MutedInfoReason = "capture" | "extension" | "user";
type MutedInfo = {
    muted: boolean;
    extensionId?: string;
    reason: MutedInfoReason;
};

interface ChromeTab {
    active: boolean;
    audible?: boolean;
    autoDiscardable?: boolean;
    cookieStoreId?: string;
    discarded?: boolean;
    favIconUrl?: string;
    height?: number;
    highlighted: boolean;
    id?: number;
    incognito: boolean;
    index: number;
    isArticle: boolean;
    isInReaderMode: boolean;
    lastAccessed: number;
    mutedInfo?: MutedInfo;
    openerTabId?: number;
    pinned: boolean;
    selected: boolean;
    sessionId?: string;
    status?: string;
    title?: string;
    url?: string;
    width?: number;
    windowId: number;
}

type State = "active" | "audible" | "collapsed" | "complete" | "discarded" | "incognito" | "loading" | "muted"
    | "pinned" | "subtree-collapsed" | "group-tab"
type Tab = {
    id: number,
    states: State[],
    children: Tab[],
    ancestorTabIds: number[]
};
//</editor-fold>
//<editor-fold desc="Create Context Menu Item">
type ContextMenuCreate = 'fake-contextMenu-create'
type ContextMenuCreateContext = "page" | "tab"

interface CreateMenuItemParameters {
    id?: string;
    title?: string;
    contexts?: ContextMenuCreateContext[];
    parentId?: number | string;
}

interface CreateMenuItemProperties extends CreateMenuItemParameters {
    type: ContextMenuCreate;
}

declare namespace browser.menus {
    function update(params: CreateMenuItemParameters): Promise<void>;
}
declare namespace browser.runtime {
    function sendMessage(extensionId: string, message: CreateMenuItemProperties): Promise<void>;
}
//</editor-fold>
//<editor-fold desc="Update Context Menu Item">
type ContextMenuUpdate = 'fake-contextMenu-update'

interface UpdateContextMenuParameters {
    id: string;
    title: string;
}

interface UpdateContextMenuItemPropeties extends UpdateContextMenuParameters {
    type: ContextMenuUpdate,
}

declare namespace browser.menus {
    function update(params: UpdateContextMenuParameters): Promise<void>;
}
declare namespace browser.runtime {
    function sendMessage(extensionId: string, message: UpdateContextMenuItemPropeties): Promise<void>;
}
//</editor-fold>
//<editor-fold desc="Remove Context Menu Item">
type ContextMenuRemove = 'fake-contextMenu-remove'
type ContextMenuRemoveCommand = string;

interface RemoveContextMenuItemPropeties {
    type: ContextMenuRemove,
    command: ContextMenuRemoveCommand
}

declare namespace browser.menus {
    function update(params: ContextMenuRemoveCommand): Promise<void>;
}
declare namespace browser.runtime {
    function sendMessage(extensionId: string, message: RemoveContextMenuItemPropeties): Promise<void>;
}
//</editor-fold>
//<editor-fold desc="Remove All Context Menu Items">
type RemoveAllContextItems = 'fake-contextMenu-update'

interface RemoveAllContextMenuItemPropeties {
    type: RemoveAllContextItems,
}

declare namespace browser.runtime {
    function sendMessage(extensionId: string, message: RemoveAllContextMenuItemPropeties): Promise<void>;
}
//</editor-fold>
//<editor-fold desc="Get Tabs">
type TabAlias = | 'current' | 'active' | 'next' | 'nextSibling' | 'previous' | 'prev' | 'previousSibling'
    | 'prevSibling' | 'senderTab';
type TabId = number | TabAlias;

type GetTree = 'get-tree';
//<editor-fold desc="Get Tree Info For Single Tab">
/*Get tree information for specific single tab
 You should give the ID of a tab via the tab parameter, to get tree information of single tab. For example:
 `var tab = await browser.runtime.sendMessage(kTST_ID, {
 type: 'get-tree',
 tab:  2
 });
 tab =>
 {
 id: 2, ...
 states: ["active", "complete"],
 children: [
 {
 id: 3, ...
 states: ["complete"],
 children: [],
 ancestorTabIds: [2]
 },
 {
 id: 4, ...
 states: ["subtree-collapsed", "complete"],
 children: [
 {
 id: 5, ...
 states: ["collapsed", "complete"],
 children: [],
 ancestorTabIds: [2, 4]
 }
 ],
 ancestorTabIds: [2]
 }
 ],
 ancestorTabIds: []
 }`
 */
type GetTabSingleMessage = {
    type: GetTree,
    tab: number,
}
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: GetTabSingleMessage): Promise<Tab>;
}
//</editor-fold>
//<editor-fold desc="Get Specific Multiple Tabs">
/*##Get tree information for specific multiple tabs
 You should give an map of IDs of tabs via the tabs parameter, to get tree information of multiple tab at a time. For example:
 `var tabs = await browser.runtime.sendMessage(kTST_ID, {
 type: 'get-tree',
 tabs:  [1, 2]
 });
 tabs =>
 [
 { id: 1, ...
 states: ["pinned", "complete"],
 children: [] },
 { id: 2, ...
 states: ["active", "complete"],
 children: [...] }
 ]`
 */
type GetMultipleTabsMessage = {
    type: GetTree;
    tabs: number[] | '*';
}
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, properties: GetMultipleTabsMessage): Promise<Tab[]>;
}
//</editor-fold>
//<editor-fold desc="Get Tree Info For Window">
/*##Get tree information for all tabs in a specific window
 You should give an window ID via the window parameter, to get clear tree information of a window at a time. For example:
 `var tabs = await browser.runtime.sendMessage(kTST_ID, {
 type:   'get-tree',
 window: 1
 });`
 tabs =>
 [
 { id: 1, ... },
 { id: 2, ...
 children: [
 { id: 3, ... },
 { id: 4, ...
 children: [
 { id: 5, ... }
 ] }
 ] },
 { id: 6, ...
 children: [
 { id: 7, ... }
 ] }
 ]
 Note that only root tabs appear in the map (id=1, 2, 6). As the result, you need to scan children of each tab to
 retrieve all tabs. If you hope to get a flat list of all tabs in the current window, see the next section.*/
type GetTabsForWindowMessage = {
    type: GetTree;
    window: number;
}
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, properties: GetTabsForWindowMessage): Promise<Tab[]>;
}
//</editor-fold>
//<editor-fold desc="Get All Tabs For Window In Flat Array">
/*Get tree information for all tabs in a window, as a flat map
 You should give a string * via tab or tabs parameter, to get tree information of all tabs at a time as a flat map. For example:
     `var tabs = await browser.runtime.sendMessage(kTST_ID, {
     type:   'get-tree',
     window: 1,
     tabs:   '*'
     });`
 tabs =>
 [
     { id: 1, ... },
     { id: 2, ...
         children: [
             { id: 3, ... },
             { id: 4, ...
                 children: [
                     { id: 5, ... }
                 ] }
             ] },
         { id: 3, ... },
         { id: 4, ...
             children: [
             { id: 5, ... }
         ] },
         { id: 5, ... },
         { id: 6, ...
             children: [
                { id: 7, ... }
            ] },
     { id: 7, ... }
 ]
 Note that some tabs appear multiple times (id=3, 4, 5, 7). This is because the wildcard * always collects tree
 information from all tabs. If you don't need such duplicated information, see the previous section.
 If you omit the window parameter, tabs in the last focused window will be returned.*/
type GetWindowTabsFlatMessage = {
    type: GetTree;
    window?: number;
    tabs: '*';
    tab?: '*';
}
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, properties: GetWindowTabsFlatMessage): Promise<Tab[]>;
}
//</editor-fold>
//</editor-fold>
//<editor-fold desc="Indent/Demote tab">
/*##Indent (demote) tab
 indent (and demote) message attaches the specified tab to its previous sibling tab. For example:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:           'indent', // or 'demote'
 tab:            'current', // required, tabs.Tab.id or alias
 followChildren: false // optional, boolean (default=false)
 });`
 If you specify an option followChildren:true, all of descendants are indented together. Otherwise descendants are
 detached from the specified tab and only the tab is indented.*/
type IndentMessage = {
    type: 'indent' | 'demote';
    tab: TabId;
    followChildren?: boolean;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: IndentMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Outdent/Promote tab">
/*##Outdent (promote) tab
 outdent (and promote) message attaches the specified tab to its grand-parent tab. For example:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:           'outdent', // or 'promote'
 tab:            'current', // required, tabs.Tab.id or alias
 followChildren: false // optional, boolean (default=false)
 });`
 If you specify an option followChildren:true, all of descendants are outdented together. Otherwise descendants are
 detached from the specified tab and only the tab is outdented.*/
type OutdentMessage = {
    type: 'outdent' | 'premote';
    tab: TabId;
    followChildren?: boolean;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: OutdentMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Attach Tab as Child">
/*##Attach existing tab to another as a child
 attach message attaches an existing tab to different tab as its child. For example:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:         'attach',
 parent:       6, // required, tabs.Tab.id or alias
 child:        9, // required, tabs.Tab.id or alias
 insertBefore: 8, // optional, tabs.Tab.id or alias
 insertAfter:  7, // optional, tabs.Tab.id or alias
 });`
 If the new child tab is already attached to different parent, then it is implicitly detached from its old parent.
 You can give optional parameter insertBefore and/or insertAfter to control where the attached tab is placed at.
 Otherwise the attached tab will be placed at top or bottom of existing children.*/
type AttachMessage = {
    type: 'attach';
    parent: TabId;
    child: TabId;
    insertBefore?: TabId;
    insertAfter?: TabId;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: AttachMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Detach Tab">
/*##Detach existing child tab from its parent
 detach message detaches a child tab from its parent. For example:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type: 'detach',
 tab:  9 // required, tabs.Tab.id or alias
 });`
 Note that detached tab (and its descendants) stays there. In other words, if you detach a child tab from a tree,
 you must move detached tab (and its descendants) to somewhere like after the last tab manually.*/
type DetachMessage = {
    type: 'detach';
    tab: TabId;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: DetachMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Collapse Tree">
/*##Collapse expanded tree
 collapse-tree message collapses an existing tree.
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type: 'collapse-tree',
 tab:  2 // required, tabs.Tab.id or alias
 });`
 It always succeeds if the tab has no child or it is already collapsed.*/
type CollapseMessage = {
    type: 'collpase-tree';
    tab: TabId;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: CollapseMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Expand Tree">
/*##Expand collapsed tree
 expand-tree message expands an existing tree.
 ` var success = await browser.runtime.sendMessage(kTST_ID, {
 type: 'expand-tree',
 tab:  2 // required, tabs.Tab.id or alias
 });`
 It always succeeds if the tab has no child or it is already expanded.*/
type ExpandMessage = {
    type: 'expand-tree';
    tab: TabId;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: ExpandMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Move Tree">
/*##Move tree to different position
 There is no specific API to move tree of tabs to different position. Please use browser.tabs.move() simply to move
 tree of tabs.
 - When a parent tab is moved in same window, all descendant tabs are also moved together automatically.
 - When a parent tab is moved across windows, all descendant tabs are left in the source window. In this case,
 if you hope that a whole tree is moved to different window, then you need to move descendant tabs to the
 destination window and restructure tree manually.
 On TST 2.4.4 and later, there are more special APIs to move tabs on the tree: move-up and move-down. These APIs
 accept an optional parameter followChildren (it's false by default) so they will help you to move a parent tab
 without its children, like:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:           'move-up',
 tab:            'current', // required, tabs.Tab.id or alias
 followChildren: false // optional, boolean (default=false)
 });`
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:           'move-down',
 tab:            'current', // required, tabs.Tab.id or alias
 followChildren: false // optional, boolean (default=false)
 });`
 */
type MoveMessage = {
    type: 'move-up' | 'move-down';
    tab: TabId;
    followChildren?: boolean;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: MoveMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Focus">
/*##Focus to the next/previous sibling tab
 focus message focuses to the specified tab. For example:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:     'focus',
 tab:      'nextSibling', // required, tabs.Tab.id or alias
 silently: false // optional, boolean (default=false)
 });`
 The tab parameter accepts alias name of tabs, so nextSibling will focus to the next sibling tab, previousSibling
 will focus to the previous sibling tab.
 If you specify an option silently:true, children of focused tab will be kept collapsed. Otherwise TST expands the
 tree of focused tab automatically.*/
type FocusMessage = {
    type: 'focus';
    tab: TabId;
    silently?: boolean;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: FocusMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Duplicate">
/*##Duplicate tab as child/sibling tab
 duplicate message duplicates the specified tab at the specified position. For example:
 ` var success = await browser.runtime.sendMessage(kTST_ID, {
 type: 'duplicate',
 tab:  'current', // required, tabs.Tab.id or alias
 as:   'child' // optional, string
 });`
 Here is the list of available value for the as option:
 - `sibling`: duplicated tab will be placed just next to the source tab.
 - `nextSibling`: duplicated tab will be placed as the next sibling of the source tab.
 - `child`: duplicated tab - will be placed as a child of the source tab.
 - `orphan` (default): duplicated tab will be placed at the end of the tab bar.
 */
type DuplicateAs = 'sibling' | 'nextSibling' | 'child' | 'orphan';
type DuplicateMessage = {
    type: 'duplicate';
    tab: TabId;
    as?: DuplicateAs;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: DuplicateMessage): Promise<boolean>;
}
//</editor-fold>
//<editor-fold desc="Create Group">
/* ##Create new group from given tabs
 group-tabs message creates a new tree from specified tabs. Tabs will be grouped under a dummy parent tab.
 For example:
 `var parentTab = await browser.runtime.sendMessage(kTST_ID, {
 type: 'group-tabs',
 tabs: [1, 2, 3] // require`
 */
type CreateGroupMessage = {
    type: 'group-tabs';
    tabs: TabId[];
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: CreateGroupMessage): Promise<Tab>;
}
//</editor-fold>
//<editor-fold desc="Scroll Tab Bar">
/*##Scroll the tab bar
 scroll message scrolls the tab bar.
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type: 'scroll',
 ...
 });`
 There are three forms of its usage:
 - Scrolling to a tab. In this form, you must specify an ID of a tab, like:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type: 'scroll',
 tab:  2 // integer, an ID of a tab
 });`
 Note that this does nothing if the specified tab is already visible.
 - Scrolling to absolute position. In this form, you must specify an ID of a window and absolute position, like:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:     'scroll',
 window:   3,  // integer, an ID of a window
 position: 250 // integer, an absolute scroll position in pixels
 });`
 - Scrolling by relative delta In this form, you must specify an ID of a window and delta, like:
 `var success = await browser.runtime.sendMessage(kTST_ID, {
 type:   'scroll',
 window: 3,  // integer, an ID of a window
 delta:  -20 // integer, a relative scroll in pixels
 });`
 */
type ScrollMessage = {
    type: 'scroll';
    tab?: TabId;
    window?: number;
    position?: number;
    delta?: number;
};
declare namespace browser.runtime {
    function sendMessage(extensionId: TstId, message: ScrollMessage): Promise<boolean>;
}
//</editor-fold>
//todo https://github.com/piroor/treestyletab/wiki/API-for-other-addons#override-reaction-for-mouse-wheel-rotation-on-the-vertical-tab-bar
//<editor-fold desc="Message Types">
interface Msg {
    type: string;
}

interface MenuItemClickMessage extends Msg {
    type: 'fake-contextMenu-click';
    info: OnClickData;
    tab: Tab;
}

interface TabClosedMessage extends Msg {
    type: "try-move-focus-from-closing-current-tab";
    tab: Tab;
    window: number;
}

interface TabClickedMessage extends Msg {
    type: 'tab-clicked';
    tab: Tab;
    window: number;
    button: 0 | 1;
    ctrlKey: boolean;
    shiftKey: boolean;
    metaKey: boolean;
}

interface NonTabAreaClickedMessage extends Msg {
    type: 'tabbar-clicked';
    window: number;
    button: 0 | 1;
    isMiddleClick: boolean;
    ctrlKey: boolean;
    shiftKey: boolean;
    metaKey: boolean;
}

interface MouseOverTabsMessage extends Msg {
    type: 'tab-mousemove' | 'tab-mouseover' | 'tab-mouseout';
    window: number;
    tab: Tab;
    ctrlKey: boolean;
    shiftKey: boolean;
    altKey: boolean;
    metaKey: boolean;
    dragging: boolean;
}

export type Message = MenuItemClickMessage | TabClosedMessage | TabClickedMessage | NonTabAreaClickedMessage
    | MouseOverTabsMessage;
//</editor-fold>
declare function executeInBackground<T>(fn:(T)=>void,params:T[]):Promise<void>;
//</editor-fold
declare namespace browser.menus {
    const ACTION_MENU_TOP_LEVEL_LIMIT: number;
    function create(createProperties: Properties, callback?: () => void): number | string;
    function update(id: number | string, updateProperties: Properties): Promise<void>;
    function remove(menuItemId: number | string): Promise<void>;
    function removeAll(): Promise<void>;
    function update(id: number | string, updateProperties: Properties): Promise<void>;
}
declare namespace browser.contextMenus {
    const ACTION_MENU_TOP_LEVEL_LIMIT: number;
    function create(createProperties: Properties, callback?: () => void): number | string;
    function update(id: number | string, updateProperties: Properties): Promise<void>;
    function remove(menuItemId: number | string): Promise<void>;
    function removeAll(): Promise<void>;
    const onClicked: EvListener<ContextMenuOnClickedFunction>;
}
declare namespace browser.runtime {
    function sendMessage<T = any, U = any>(extensionId: string, message: T): Promise<U>;
    type onMessagePromise = (message: object, sender: MessageSender, sendResponse: (response: object) => boolean) => Promise<void>;
    type onMessageBool = (message: object, sender: MessageSender, sendResponse: (response: object) => Promise<void>) => boolean;
    type onMessageVoid = (message: object, sender: MessageSender, sendResponse: (response: object) => Promise<void>) => void;
    type onMessageEvent = onMessagePromise | onMessageBool | onMessageVoid;

    export type SendResponseFunction = (response: object) => boolean | Promise<void>;
    export type AddListenerCallback = (message: Message, sender?: MessageSender, sendResponse?: SendResponseFunction) => Promise<void>;
    export type ListenerCallback<T> = (message:T,sender?:MessageSender, sendResponse?:SendResponseFunction) => Promise<void>;
    /*export type Listener<TMessage,T extends ListenerCallback<TMessage>> = {
        addListener: ListenerCallback<TMessage>
        removeListener: (listener: ListenerCallback<TMessage>) => void;
        hasListener: (listener: ListenerCallback<TMessage>) => boolean;
    }*/
    const onMessageExternal: EvListener<onMessageEvent>;
              //EvListener<onMessageEvent>;
    //<editor-fold desc="unused">
    const lastError: string | null;
    const id: string;
    type Port = {
        name: string;
        disconnect(): void;
        error: object;
        onDisconnect: {
            addListener(cb: (port: Port) => void): void;
            removeListener(cb: (port: Port) => void): void;
        };
        onMessage: {
            addListener(cb: (message: object) => void): void;
            removeListener(cb: (message: object) => void): void;
        };
        postMessage(message: object): void;
        sender?: runtime.MessageSender;
    };
    type MessageSender = {
        tab?: Tab;
        frameId?: number;
        id?: string;
        url?: string;
        tlsChannelId?: string;
    };
    type PlatformOs = "mac" | "win" | "android" | "cros" | "linux" | "openbsd";
    type PlatformArch = "arm" | "x86-32" | "x86-64";
    type PlatformNaclArch = "arm" | "x86-32" | "x86-64";
    type PlatformInfo = {
        os: PlatformOs;
        arch: PlatformArch;
    };
    // type RequestUpdateCheckStatus = "throttled" | "no_update" | "update_available";
    type OnInstalledReason = "install" | "update" | "chrome_update" | "shared_module_update";
    type OnRestartRequiredReason = "app_update" | "os_update" | "periodic";
    type FirefoxSpecificProperties = {
        id?: string;
        strict_min_version?: string;
        strict_max_version?: string;
        update_url?: string;
    };
    type IconPath = { [urlName: string]: string } | string;
    type Manifest = {
        // Required
        manifest_version: 2;
        name: string;
        version: string;
        /** Required in Microsoft Edge */
        author?: string;
        // Optional
        // ManifestBase
        description?: string;
        homepage_url?: string;
        short_name?: string;
        // WebExtensionManifest
        background?: {
            page: string;
            script: string[];
            persistent?: boolean;
        };
        content_scripts?: {
            matches: string[];
            exclude_matches?: string[];
            include_globs?: string[];
            exclude_globs?: string[];
            css?: string[];
            js?: string[];
            all_frames?: boolean;
            match_about_blank?: boolean;
            run_at?: "document_start" | "document_end" | "document_idle";
        }[];
        content_security_policy?: string;
        developer?: {
            name?: string;
            url?: string;
        };
        icons?: {
            [imgSize: string]: string;
        };
        incognito?: "spanning" | "split" | "not_allowed";
        optional_permissions?: browser.permissions.Permission[];
        options_ui?: {
            page: string;
            browser_style?: boolean;
            chrome_style?: boolean;
            open_in_tab?: boolean;
        };
        permissions?: browser.permissions.Permission[];
        web_accessible_resources?: string[];
        // WebExtensionLangpackManifest
        languages: {
            [langCode: string]: {
                chrome_resources: {
                    [resName: string]: string | { [urlName: string]: string };
                };
                version: string;
            };
        };
        langpack_id?: string;
        sources?: {
            [srcName: string]: {
                base_path: string;
                paths?: string[];
            };
        };
        // Extracted from components
        browser_action?: {
            default_title?: string;
            default_icon?: IconPath;
            theme_icons?: {
                light: string;
                dark: string;
                size: number;
            }[];
            default_popup?: string;
            browser_style?: boolean;
            default_area?: "navbar" | "menupanel" | "tabstrip" | "personaltoolbar";
        };
        commands?: {
            [keyName: string]: {
                suggested_key?: {
                    default?: string;
                    mac?: string;
                    linux?: string;
                    windows?: string;
                    chromeos?: string;
                    android?: string;
                    ios?: string;
                };
                description?: string;
            };
        };
        default_locale?: browser.i18n.LanguageCode;
        devtools_page?: string;
        omnibox?: {
            keyword: string;
        };
        page_action?: {
            default_title?: string;
            default_icon?: IconPath;
            default_popup?: string;
            browser_style?: boolean;
            show_matches?: string[];
            hide_matches?: string[];
        };
        sidebar_action?: {
            default_panel: string;
            default_title?: string;
            default_icon?: IconPath;
            browser_style?: boolean;
        };
        // Firefox specific
        applications?: {
            gecko?: FirefoxSpecificProperties;
        };
        browser_specific_settings?: {
            gecko?: FirefoxSpecificProperties;
        };
        experiment_apis?: any;
        protocol_handlers?: {
            name: string;
            protocol: string;
            uriTemplate: string;
        };
        // Opera specific
        minimum_opera_version?: string;
        // Chrome specific
        action?: any;
        automation?: any;
        background_page?: any;
        chrome_settings_overrides?: {
            homepage?: string;
            search_provider?: {
                name: string;
                search_url: string;
                keyword?: string;
                favicon_url?: string;
                suggest_url?: string;
                instant_url?: string;
                is_default?: string;
                image_url?: string;
                search_url_post_params?: string;
                instant_url_post_params?: string;
                image_url_post_params?: string;
                alternate_urls?: string[];
                prepopulated_id?: number;
            };
        };
        chrome_ui_overrides?: {
            bookmarks_ui?: {
                remove_bookmark_shortcut?: true;
                remove_button?: true;
            };
        };
        chrome_url_overrides?: {
            newtab?: string;
            bookmarks?: string;
            history?: string;
        };
        content_capabilities?: any;
        converted_from_user_script?: any;
        current_locale?: any;
        declarative_net_request?: any;
        event_rules?: any[];
        export?: {
            whitelist?: string[];
        };
        externally_connectable?: {
            ids?: string[];
            matches?: string[];
            accepts_tls_channel_id?: boolean;
        };
        file_browser_handlers?: {
            id: string;
            default_title: string;
            file_filters: string[];
        }[];
        file_system_provider_capabilities?: {
            source: "file" | "device" | "network";
            configurable?: boolean;
            multiple_mounts?: boolean;
            watchable?: boolean;
        };
        import?: {
            id: string;
            minimum_version?: string;
        }[];
        input_components?: any;
        key?: string;
        minimum_chrome_version?: string;
        nacl_modules?: {
            path: string;
            mime_type: string;
        }[];
        oauth2?: any;
        offline_enabled?: boolean;
        options_page?: string;
        platforms?: any;
        requirements?: any;
        sandbox?: {
            pages: string[];
            content_security_policy?: string;
        }[];
        signature?: any;
        spellcheck?: any;
        storage?: {
            managed_schema: string;
        };
        system_indicator?: any;
        tts_engine?: {
            voice: {
                voice_name: string;
                lang?: string;
                gender?: "male" | "female";
                event_types: (
                    | "start"
                    | "word"
                    | "sentence"
                    | "marker"
                    | "end"
                    | "error")[];
            }[];
        };
        update_url?: string;
        version_name?: string;
    };
    function getBackgroundPage(): Promise<Window>;
    function openOptionsPage(): Promise<void>;
    function getManifest(): Manifest;
    function getURL(path: string): string;
    function setUninstallURL(url: string): Promise<void>;
    function reload(): void;
    // Will not exist: https://bugzilla.mozilla.org/show_bug.cgi?id=1314922
    // function RequestUpdateCheck(): Promise<RequestUpdateCheckStatus>;
    function connect(extensionId?: string, connectInfo?: { name?: string; includeTlsChannelId?: boolean }): Port;
    function connectNative(application: string): Port;
    function sendMessage<T = any, U = any>(message: T): Promise<U>;
    function sendMessage<T = any, U = any>(message: T,
                                           options: { includeTlsChannelId?: boolean; toProxyScript?: boolean }): Promise<U>;
    function sendMessage<T = any, U = any>(extensionId: string,
                                           message: T,
                                           options?: { includeTlsChannelId?: boolean; toProxyScript?: boolean }): Promise<U>;
    function sendNativeMessage(application: string, message: object): Promise<object | void>;
    function getPlatformInfo(): Promise<PlatformInfo>;
    function getBrowserInfo(): Promise<{
        name: string;
        vendor: string;
        version: string;
        buildID: string;
    }>;

    // Unsupported: https://bugzilla.mozilla.org/show_bug.cgi?id=1339407
    // function getPackageDirectoryEntry(): Promise<any>;
    const onStartup: Listener<void>;
    const onInstalled: Listener<{
        reason: OnInstalledReason;
        previousVersion?: string;
        id?: string;
    }>;
    // Unsupported
    // const onSuspend: Listener<void>;
    // const onSuspendCanceled: Listener<void>;
    // const onBrowserUpdateAvailable: Listener<void>;
    // const onRestartRequired: Listener<OnRestartRequiredReason>;
    const onUpdateAvailable: Listener<{ version: string }>;
    const onConnect: Listener<Port>;
    const onConnectExternal: Listener<Port>;

    const onMessage: EvListener<onMessageEvent>;

    //</editor-fold>
}
declare namespace browser.tabs {

    // TODO: Specify PageSettings properly.
    type PageSettings = object;

    type TabStatus = "loading" | "complete";
    type WindowType = "normal" | "popup" | "panel" | "devtools";
    type ZoomSettingsMode = "automatic" | "disabled" | "manual";
    type ZoomSettingsScope = "per-origin" | "per-tab";
    type ZoomSettings = {
        defaultZoomFactor?: number;
        mode?: ZoomSettingsMode;
        scope?: ZoomSettingsScope;
    };
    const TAB_ID_NONE: number;
    function connect(tabId: number, connectInfo?: { name?: string; frameId?: number }): browser.runtime.Port;
    function create(createProperties: {
        active?: boolean;
        cookieStoreId?: string;
        index?: number;
        openerTabId?: number;
        pinned?: boolean;
        // deprecated: selected: boolean,
        url?: string;
        windowId?: number;
    }): Promise<ChromeTab>;
    function captureVisibleTab(windowId?: number, options?: browser.extensionTypes.ImageDetails): Promise<string>;
    function detectLanguage(tabId?: number): Promise<string>;
    function duplicate(tabId: number): Promise<ChromeTab>;
    function executeScript(tabId: number | undefined, details: browser.extensionTypes.InjectDetails): Promise<object[]>;
    function get(tabId: number): Promise<ChromeTab>;
    // deprecated: function getAllInWindow(): x;
    function getCurrent(): Promise<ChromeTab>;
    // deprecated: function getSelected(windowId?: number): Promise<Tab>;
    function getZoom(tabId?: number): Promise<number>;
    function getZoomSettings(tabId?: number): Promise<ZoomSettings>;
    // unsupported: function highlight(highlightInfo: {
    //     windowId?: number,
    //     tabs: number[]|number,
    // }): Promise<browser.windows.Window>;
    function insertCSS(tabId: number | undefined, details: browser.extensionTypes.InjectDetailsCSS): Promise<void>;
    function removeCSS(tabId: number | undefined, details: browser.extensionTypes.InjectDetails): Promise<void>;
    function move(tabIds: number | number[],
                  moveProperties: { windowId?: number; index: number; }): Promise<ChromeTab | ChromeTab[]>;
    function print(): Promise<void>;
    function printPreview(): Promise<void>;

    interface QueryInfo {
        active?: boolean;
        audible?: boolean;
        // unsupported: autoDiscardable?: boolean,
        cookieStoreId?: string;
        currentWindow?: boolean;
        discarded?: boolean;
        highlighted?: boolean;
        index?: number;
        muted?: boolean;
        lastFocusedWindow?: boolean;
        pinned?: boolean;
        status?: TabStatus;
        title?: string;
        url?: string | string[];
        windowId?: number;
        windowType?: WindowType;
    }
    function query(queryInfo: QueryInfo): Promise<ChromeTab[]>;
    function reload(tabId?: number, reloadProperties?: { bypassCache?: boolean }): Promise<void>;
    function remove(tabIds: number | number[]): Promise<void>;
    function saveAsPDF(pageSettings: PageSettings): Promise<"saved" | "replaced" | "canceled" | "not_saved" | "not_replaced">;
    function sendMessage<T = any, U = object>(tabId: number,
                                              message: T,
                                              options?: { frameId?: number }): Promise<U | void>;
    // deprecated: function sendRequest(): x;
    function setZoom(tabId: number | undefined, zoomFactor: number): Promise<void>;
    function setZoomSettings(tabId: number | undefined, zoomSettings: ZoomSettings): Promise<void>;
    function update(tabId: number | undefined, updateProperties: {
        active?: boolean;
        // unsupported: autoDiscardable?: boolean,
        // unsupported: highlighted?: boolean,
        loadReplace?: boolean;
        muted?: boolean;
        openerTabId?: number;
        pinned?: boolean;
        // deprecated: selected?: boolean,
        url?: string;
    }): Promise<ChromeTab>;
    const onActivated: Listener<{ tabId: number; windowId: number }>;
    const onAttached: EvListener<(tabId: number, attachInfo: {
        newWindowId: number;
        newPosition: number;
    }) => void>;
    const onCreated: Listener<ChromeTab>;
    const onDetached: EvListener<(tabId: number, detachInfo: {
        oldWindowId: number;
        oldPosition: number;
    }) => void>;
    const onHighlighted: Listener<{ windowId: number; tabIds: number[] }>;
    const onMoved: EvListener<(tabId: number, moveInfo: {
        windowId: number;
        fromIndex: number;
        toIndex: number;
    }) => void>;
    const onRemoved: EvListener<(tabId: number, removeInfo: {
        windowId: number;
        isWindowClosing: boolean;
    }) => void>;
    const onReplaced: EvListener<(addedTabId: number, removedTabId: number) => void>;
    const onUpdated: EvListener<(tabId: number, changeInfo: {
        audible?: boolean;
        discarded?: boolean;
        favIconUrl?: string;
        mutedInfo?: MutedInfo;
        pinned?: boolean;
        status?: string;
        title?: string;
        url?: string;
    }, tab: ChromeTab) => void>;
    const onZoomChanged: Listener<{
        tabId: number;
        oldZoomFactor: number;
        newZoomFactor: number;
        zoomSettings: ZoomSettings;
    }>;
}

//<editor-fold desc="All unused">
//<editor-fold desc="alarms bookmarks browserAction browsingData command">
declare namespace browser.alarms {
    type Alarm = {
        name: string;
        scheduledTime: number;
        periodInMinutes?: number;
    };

    type When = {
        when?: number;
        periodInMinutes?: number;
    };
    type DelayInMinutes = {
        delayInMinutes?: number;
        periodInMinutes?: number;
    };

    function create(name?: string, alarmInfo?: When | DelayInMinutes): void;

    function get(name?: string): Promise<Alarm | undefined>;

    function getAll(): Promise<Alarm[]>;

    function clear(name?: string): Promise<boolean>;

    function clearAll(): Promise<boolean>;

    const onAlarm: Listener<Alarm>;
}
declare namespace browser.bookmarks {
    type BookmarkTreeNodeUnmodifiable = "managed";
    type BookmarkTreeNodeType = "bookmark" | "folder" | "separator";
    type BookmarkTreeNode = {
        id: string;
        parentId?: string;
        index?: number;
        url?: string;
        title: string;
        dateAdded?: number;
        dateGroupModified?: number;
        unmodifiable?: BookmarkTreeNodeUnmodifiable;
        children?: BookmarkTreeNode[];
        type?: BookmarkTreeNodeType;
    };

    type CreateDetails = {
        parentId?: string;
        index?: number;
        title?: string;
        url?: string;
    };

    function create(bookmark: CreateDetails): Promise<BookmarkTreeNode>;

    function get(idOrIdList: string | string[]): Promise<BookmarkTreeNode[]>;

    function getChildren(id: string): Promise<BookmarkTreeNode[]>;

    function getRecent(numberOfItems: number): Promise<BookmarkTreeNode[]>;

    function getSubTree(id: string): Promise<[BookmarkTreeNode]>;

    function getTree(): Promise<[BookmarkTreeNode]>;

    type Destination =
        | {
        parentId: string;
        index?: number;
    }
        | {
        index: number;
        parentId?: string;
    };

    function move(
        id: string,
        destination: Destination
    ): Promise<BookmarkTreeNode>;

    function remove(id: string): Promise<void>;

    function removeTree(id: string): Promise<void>;

    function search(
        query:
            | string
            | {
            query?: string;
            url?: string;
            title?: string;
        }
    ): Promise<BookmarkTreeNode[]>;

    function update(
        id: string,
        changes: { title: string; url: string }
    ): Promise<BookmarkTreeNode>;

    const onCreated: EvListener<(id: string, bookmark: BookmarkTreeNode) => void>;
    const onRemoved: EvListener<(
        id: string,
        removeInfo: {
            parentId: string;
            index: number;
            node: BookmarkTreeNode;
        }
    ) => void>;
    const onChanged: EvListener<(
        id: string,
        changeInfo: {
            title: string;
            url?: string;
        }
    ) => void>;
    const onMoved: EvListener<(
        id: string,
        moveInfo: {
            parentId: string;
            index: number;
            oldParentId: string;
            oldIndex: number;
        }
    ) => void>;
}
declare namespace browser.browserAction {
    type ColorArray = [number, number, number, number];
    type ImageDataType = ImageData;

    function setTitle(details: { title: string | null; tabId?: number }): void;

    function getTitle(details: { tabId?: number }): Promise<string>;

    type IconViaPath = {
        path: string | { [size: number]: string };
        tabId?: number;
    };

    type IconViaImageData = {
        imageData: ImageDataType | { [size: number]: ImageDataType };
        tabId?: number;
    };

    type IconReset = {
        imageData?: {} | null;
        path?: {} | null;
        tabId?: number;
    };

    function setIcon(
        details: IconViaPath | IconViaImageData | IconReset
    ): Promise<void>;

    function setPopup(details: { popup: string | null; tabId?: number }): void;

    function getPopup(details: { tabId?: number }): Promise<string>;

    function openPopup(): Promise<void>;

    function setBadgeText(details: { text: string | null; tabId?: number }): void;

    function getBadgeText(details: { tabId?: number }): Promise<string>;

    function setBadgeBackgroundColor(details: {
        color: string | ColorArray | null;
        tabId?: number;
    }): void;

    function getBadgeBackgroundColor(details: {
        tabId?: number;
    }): Promise<ColorArray>;

    function enable(tabId?: number): void;

    function disable(tabId?: number): void;

    const onClicked: Listener<ChromeTab>;
}
declare namespace browser.browsingData {
    type DataTypeSet = {
        cache?: boolean;
        cookies?: boolean;
        downloads?: boolean;
        fileSystems?: boolean;
        formData?: boolean;
        history?: boolean;
        indexedDB?: boolean;
        localStorage?: boolean;
        passwords?: boolean;
        pluginData?: boolean;
        serverBoundCertificates?: boolean;
        serviceWorkers?: boolean;
    };

    type DataRemovalOptions = {
        since?: number;
        originTypes?: { unprotectedWeb: boolean };
    };

    function remove(
        removalOptions: DataRemovalOptions,
        dataTypes: DataTypeSet
    ): Promise<void>;

    function removeCache(removalOptions?: DataRemovalOptions): Promise<void>;

    function removeCookies(removalOptions: DataRemovalOptions): Promise<void>;

    function removeDownloads(removalOptions: DataRemovalOptions): Promise<void>;

    function removeFormData(removalOptions: DataRemovalOptions): Promise<void>;

    function removeHistory(removalOptions: DataRemovalOptions): Promise<void>;

    function removePasswords(removalOptions: DataRemovalOptions): Promise<void>;

    function removePluginData(removalOptions: DataRemovalOptions): Promise<void>;

    function settings(): Promise<{
        options: DataRemovalOptions;
        dataToRemove: DataTypeSet;
        dataRemovalPermitted: DataTypeSet;
    }>;
}
declare namespace browser.commands {
    type Command = {
        name?: string;
        description?: string;
        shortcut?: string;
    };

    function getAll(): Promise<Command[]>;

    const onCommand: Listener<string>;
}
declare namespace browser.contextualIdentities {
    type IdentityColor = "blue" | "turquoise" | "green" | "yellow" | "orange" | "red" | "pink" | "purple";
    type IdentityIcon = "fingerprint" | "briefcase" | "dollar" | "cart" | "circle";
    type ContextualIdentity = {
        cookieStoreId: string;
        color: IdentityColor;
        icon: IdentityIcon;
        name: string;
    };
    type Details = {
        name: string;
        color: IdentityColor;
        icon: IdentityIcon;
    }

    function create(details: Details): Promise<ContextualIdentity>;

    function get(cookieStoreId: string): Promise<ContextualIdentity | null>;

    function query(details: { name?: string }): Promise<ContextualIdentity[]>;

    function update(cookieStoreId: string, details: Details): Promise<ContextualIdentity>;

    function remove(cookieStoreId: string): Promise<ContextualIdentity | null>;
}
//</editor-fold>
//<editor-fold desc="unused">
declare namespace browser.cookies {
    type Cookie = {
        name: string;
        value: string;
        domain: string;
        hostOnly: boolean;
        path: string;
        secure: boolean;
        httpOnly: boolean;
        session: boolean;
        expirationDate?: number;
        storeId: string;
    };
    type CookieStore = {
        id: string;
        tabIds: number[];
    };
    type OnChangedCause = "evicted" | "expired" | "explicit" | "expired_overwrite" | "overwrite";
    function get(details: {
        url: string;
        name: string;
        storeId?: string;
    }): Promise<Cookie | null>;
    function getAll(details: {
        url?: string;
        name?: string;
        domain?: string;
        path?: string;
        secure?: boolean;
        session?: boolean;
        storeId?: string;
    }): Promise<Cookie[]>;
    function set(details: {
        url: string;
        name?: string;
        domain?: string;
        path?: string;
        secure?: boolean;
        httpOnly?: boolean;
        expirationDate?: number;
        storeId?: string;
    }): Promise<Cookie>;
    function remove(details: {
        url: string;
        name: string;
        storeId?: string;
    }): Promise<Cookie | null>;
    function getAllCookieStores(): Promise<CookieStore[]>;
    const onChanged: Listener<{
        removed: boolean;
        cookie: Cookie;
        cause: OnChangedCause;
    }>;
}
declare namespace browser.contentScripts {
    type RegisteredContentScriptOptions = {
        allFrames?: boolean;
        css?: ({ file: string } | { code: string })[];
        excludeGlobs?: string[];
        excludeMatches?: string[];
        includeGlobs?: string[];
        js?: ({ file: string } | { code: string })[];
        matchAboutBlank?: boolean;
        matches: string[];
        runAt?: "document_start" | "document_end" | "document_idle";
    };
    type RegisteredContentScript = {
        unregister: () => void;
    };
    function register(contentScriptOptions: RegisteredContentScriptOptions): Promise<RegisteredContentScript>;
}
declare namespace browser.devtools.inspectedWindow {
    const tabId: number;
    // function eval(expression: string): Promise<[any,| { isException: boolean; value: string }| { isError: boolean; code: string }]>;
    function reload(reloadOptions?: {
        ignoreCache?: boolean;userAgent?: string;
        injectedScript?: string;
    }): void;
}
declare namespace browser.devtools.network {
    const onNavigated: Listener<string>;
}
declare namespace browser.devtools.panels {
    type ExtensionPanel = {
        onShown: Listener<Window>;
        onHidden: Listener<void>;
    };
    function create(title: string, iconPath: string, pagePath: string): Promise<ExtensionPanel>;
}
declare namespace browser.downloads {
    type FilenameConflictAction = "uniquify" | "overwrite" | "prompt";
    type InterruptReason = 
        | "FILE_FAILED" | "FILE_ACCESS_DENIED" | "FILE_NO_SPACE" | "FILE_NAME_TOO_LONG" | "FILE_TOO_LARGE" | "FILE_VIRUS_INFECTED" 
        | "FILE_TRANSIENT_ERROR" | "FILE_BLOCKED" | "FILE_SECURITY_CHECK_FAILED" | "FILE_TOO_SHORT" | "NETWORK_FAILED" 
        | "NETWORK_TIMEOUT" | "NETWORK_DISCONNECTED" | "NETWORK_SERVER_DOWN" | "NETWORK_INVALID_REQUEST" | "SERVER_FAILED" 
        | "SERVER_NO_RANGE" | "SERVER_BAD_CONTENT" | "SERVER_UNAUTHORIZED" | "SERVER_CERT_PROBLEM" | "SERVER_FORBIDDEN" 
        | "USER_CANCELED" | "USER_SHUTDOWN"| "CRASH";
    type DangerType = "file" | "url" | "content" | "uncommon" | "host" | "unwanted" | "safe"| "accepted";
    type State = "in_progress" | "interrupted" | "complete";
    type DownloadItem = {
        id: number;
        url: string;
        referrer: string;
        filename: string;
        incognito: boolean;
        danger: string;
        mime: string;
        startTime: string;
        endTime?: string;
        estimatedEndTime?: string;
        state: string;
        paused: boolean;
        canResume: boolean;
        error?: string;
        bytesReceived: number;
        totalBytes: number;
        fileSize: number;
        exists: boolean;
        byExtensionId?: string;
        byExtensionName?: string;
    };
    type Delta<T> = {
        current?: T;
        previous?: T;
    };
    type StringDelta = Delta<string>;
    type DoubleDelta = Delta<number>;
    type BooleanDelta = Delta<boolean>;
    type DownloadTime = Date | string | number;
    type DownloadQuery = {
        query?: string[];
        startedBefore?: DownloadTime;
        startedAfter?: DownloadTime;
        endedBefore?: DownloadTime;
        endedAfter?: DownloadTime;
        totalBytesGreater?: number;
        totalBytesLess?: number;
        filenameRegex?: string;
        urlRegex?: string;
        limit?: number;
        orderBy?: string;
        id?: number;
        url?: string;
        filename?: string;
        danger?: DangerType;
        mime?: string;
        startTime?: string;
        endTime?: string;
        state?: State;
        paused?: boolean;
        error?: InterruptReason;
        bytesReceived?: number;
        totalBytes?: number;
        fileSize?: number;
        exists?: boolean;
    };
    function download(options: {
        url: string;
        filename?: string;
        conflictAction?: string;
        saveAs?: boolean;
        method?: string;
        headers?: { [key: string]: string };
        body?: string;
    }): Promise<number>;
    function search(query: DownloadQuery): Promise<DownloadItem[]>;
    function pause(downloadId: number): Promise<void>;
    function resume(downloadId: number): Promise<void>;
    function cancel(downloadId: number): Promise<void>;
    // unsupported: function getFileIcon(downloadId: number, options?: { size?: number }):
    //              Promise<string>;
    function open(downloadId: number): Promise<void>;
    function show(downloadId: number): Promise<void>;
    function showDefaultFolder(): void;
    function erase(query: DownloadQuery): Promise<number[]>;
    function removeFile(downloadId: number): Promise<void>;
    // unsupported: function acceptDanger(downloadId: number): Promise<void>;
    // unsupported: function drag(downloadId: number): Promise<void>;
    // unsupported: function setShelfEnabled(enabled: boolean): void;
    const onCreated: Listener<DownloadItem>;
    const onErased: Listener<number>;
    const onChanged: Listener<{
        id: number;
        url?: StringDelta;
        filename?: StringDelta;
        danger?: StringDelta;
        mime?: StringDelta;
        startTime?: StringDelta;
        endTime?: StringDelta;
        state?: StringDelta;
        canResume?: BooleanDelta;
        paused?: BooleanDelta;
        error?: StringDelta;
        totalBytes?: DoubleDelta;
        fileSize?: DoubleDelta;
        exists?: BooleanDelta;
    }>;
}
declare namespace browser.events {
    type UrlFilter = {
        hostContains?: string;
        hostEquals?: string;
        hostPrefix?: string;
        hostSuffix?: string;
        pathContains?: string;
        pathEquals?: string;
        pathPrefix?: string;
        pathSuffix?: string;
        queryContains?: string;
        queryEquals?: string;
        queryPrefix?: string;
        querySuffix?: string;
        urlContains?: string;
        urlEquals?: string;
        urlMatches?: string;
        originAndPathMatches?: string;
        urlPrefix?: string;
        urlSuffix?: string;
        schemes?: string[];
        ports?: Array<number | number[]>;
    };
}
declare namespace browser.extension {
    type ViewType = "tab" | "notification" | "popup";
    const lastError: string | null;
    const inIncognitoContext: boolean;
    function getURL(path: string): string;
    function getViews(fetchProperties?: {
        type?: ViewType;
        windowId?: number;
    }): Window[];
    function getBackgroundPage(): Window;
    function isAllowedIncognitoAccess(): Promise<boolean>;
    function isAllowedFileSchemeAccess(): Promise<boolean>;
    // unsupported: events as they are deprecated
}
declare namespace browser.extensionTypes {
    type ImageFormat = "jpeg" | "png";
    type ImageDetails = {
        format: ImageFormat;
        quality: number;
    };
    type RunAt = "document_start" | "document_end" | "document_idle";
    type InjectDetails = {
        allFrames?: boolean;
        code?: string;
        file?: string;
        frameId?: number;
        matchAboutBlank?: boolean;
        runAt?: RunAt;
    };
    type InjectDetailsCSS = InjectDetails & { cssOrigin?: "user" | "author" };
}
declare namespace browser.history {
    type TransitionType = | "link" | "typed" | "auto_bookmark" | "auto_subframe" | "manual_subframe" | "generated" 
        | "auto_toplevel" | "form_submit" | "reload" | "keyword" | "keyword_generated";

    type HistoryItem = {
        id: string;
        url?: string;
        title?: string;
        lastVisitTime?: number;
        visitCount?: number;
        typedCount?: number;
    };
    type VisitItem = {
        id: string;
        visitId: string;
        VisitTime?: number;
        refferingVisitId: string;
        transition: TransitionType;
    };
    function search(query: {
        text: string;
        startTime?: number | string | Date;
        endTime?: number | string | Date;
        maxResults?: number;
    }): Promise<HistoryItem[]>;
    function getVisits(details: { url: string }): Promise<VisitItem[]>;
    function addUrl(details: {
        url: string;
        title?: string;
        transition?: TransitionType;
        visitTime?: number | string | Date;
    }): Promise<void>;
    function deleteUrl(details: { url: string }): Promise<void>;
    function deleteRange(range: {
        startTime: number | string | Date;
        endTime: number | string | Date;
    }): Promise<void>;
    function deleteAll(): Promise<void>;
    const onVisited: Listener<HistoryItem>;
    // TODO: Ensure that urls is not `urls: [string]` instead
    const onVisitRemoved: Listener<{ allHistory: boolean; urls: string[] }>;
}
declare namespace browser.i18n {
    type LanguageCode = string;
    function getAcceptLanguages(): Promise<LanguageCode[]>;
    function getMessage(messageName: string, substitutions?: string | string[]): string;
    function getUILanguage(): LanguageCode;
    function detectLanguage(text: string) : Promise<{
                                                isReliable: boolean;
                                                languages: { language: LanguageCode; percentage: number }[];
                                              }>;
}
declare namespace browser.identity {
    function getRedirectURL(): string;
    function launchWebAuthFlow(details: {
        url: string;
        interactive: boolean;
    }): Promise<string>;
}
declare namespace browser.idle {
    type IdleState = "active" | "idle" /* unsupported: | "locked" */;
    function queryState(detectionIntervalInSeconds: number): Promise<IdleState>;
    function setDetectionInterval(intervalInSeconds: number): void;
    const onStateChanged: Listener<IdleState>;
}
declare namespace browser.management {
    type ExtensionInfo = {
        description: string;
        // unsupported: disabledReason: string,
        enabled: boolean;
        homepageUrl: string;
        hostPermissions: string[];
        icons: { size: number; url: string }[];
        id: string;
        installType: "admin" | "development" | "normal" | "sideload" | "other";
        mayDisable: boolean;
        name: string;
        // unsupported: offlineEnabled: boolean,
        optionsUrl: string;
        permissions: string[];
        shortName: string;
        // unsupported: type: string,
        updateUrl: string;
        version: string;
        // unsupported: versionName: string,
    };
    function getSelf(): Promise<ExtensionInfo>;
    function uninstallSelf(options: {
        showConfirmDialog: boolean;
        dialogMessage: string;
    }): Promise<void>;
}
declare namespace browser.notifications {
    type TemplateType = "basic" /* | "image" | "list" | "progress" */;
    type NotificationOptions = {
        type: TemplateType;
        message: string;
        title: string;
        iconUrl?: string;
    };
    function create(id: string | null, options: NotificationOptions): Promise<string>;
    function clear(id: string): Promise<boolean>;
    function getAll(): Promise<{ [key: string]: NotificationOptions }>;
    const onClosed: Listener<string>;
    const onClicked: Listener<string>;
}
declare namespace browser.omnibox {
    type OnInputEnteredDisposition = "currentTab" | "newForegroundTab"| "newBackgroundTab";
    type SuggestResult = {
        content: string;
        description: string;
    };
    function setDefaultSuggestion(suggestion: { description: string }): void;
    const onInputStarted: Listener<void>;
    const onInputChanged: EvListener<(text: string, suggest: (arg: SuggestResult[]) => void) => void>;
    const onInputEntered: EvListener<(text: string, disposition: OnInputEnteredDisposition) => void>;
    const onInputCancelled: Listener<void>;
}
declare namespace browser.pageAction {
    type ImageDataType = ImageData;
    function show(tabId: number): void;
    function hide(tabId: number): void;
    function setTitle(details: { tabId: number; title: string }): void;
    function getTitle(details: { tabId: number }): Promise<string>;
    function setIcon(details: {
        tabId: number;
        path?: string | object;
        imageData?: ImageDataType;
    }): Promise<void>;
    function setPopup(details: { tabId: number; popup: string }): void;
    function getPopup(details: { tabId: number }): Promise<string>;
    const onClicked: Listener<ChromeTab>;
}
declare namespace browser.permissions {
    type Permission =
        | "activeTab" | "alarms" | "background" | "bookmarks" | "browsingData" | "browserSettings" | "clipboardRead" 
        | "clipboardWrite" | "contextMenus" | "contextualIdentities" | "cookies" | "downloads" | "downloads.open" 
        | "find" | "geolocation" | "history" | "identity" | "idle" | "management" | "menus" | "nativeMessaging" 
        | "notifications" | "pkcs11" | "privacy" | "proxy" | "sessions" | "storage" | "tabs" | "theme" | "topSites" 
        | "unlimitedStorage" | "webNavigation" | "webRequest"| "webRequestBlocking";
    type Permissions = {
        origins?: string[];
        permissions?: Permission[];
    };
    function contains(permissions: Permissions): Promise<boolean>;
    function getAll(): Promise<Permissions>;
    function remove(permissions: Permissions): Promise<boolean>;
    function request(permissions: Permissions): Promise<boolean>;
    // Not yet support in Edge and Firefox:
    // const onAdded: Listener<Permissions>;
    // const onRemoved: Listener<Permissions>;
}
//</editor-fold>
//<editor-fold desc="unused">
declare namespace browser.sessions {
    type Filter = { maxResults?: number };
    type Session = {
        lastModified: number;
        tab: ChromeTab;
        window: browser.windows.Window;
    };
    const MAX_SESSION_RESULTS: number;
    function getRecentlyClosed(filter?: Filter): Promise<Session[]>;
    function restore(sessionId: string): Promise<Session>;
    function setTabValue(tabId: number, key: string, value: string | object): Promise<void>;
    function getTabValue(tabId: number, key: string ): Promise<void | string | object>;
    function removeTabValue(tabId: number, key: string): Promise<void>;
    function setWindowValue( windowId: number, key: string,  value: string | object): Promise<void>;
    function getWindowValue(windowId: number,key: string): Promise<void | string | object>;
    function removeWindowValue(windowId: number, key: string): Promise<void>;
    const onChanged: EvListener<() => void>;
}
declare namespace browser.sidebarAction {
    type ImageDataType = ImageData;
    function setPanel(details: { panel: string; tabId?: number }): void;
    function getPanel(details: { tabId?: number }): Promise<string>;
    function setTitle(details: { title: string; tabId?: number }): void;
    function getTitle(details: { tabId?: number }): Promise<string>;
    type IconViaPath = {
        path: string | { [index: number]: string };
        tabId?: number;
    };
    type IconViaImageData = {
        imageData: ImageDataType | { [index: number]: ImageDataType };
        tabId?: number;
    };
    function setIcon(details: IconViaPath | IconViaImageData): Promise<void>;
    function open(): Promise<void>;
    function close(): Promise<void>;
}
declare namespace browser.storage {
    // Non-firefox implementations don't accept all these types
    type StorageValue = 
        | string | number | boolean | null | undefined | RegExp | ArrayBuffer | Uint8ClampedArray | Uint8Array 
        | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array | DataView
        | StorageArray | StorageMap | StorageSet | StorageObject;
    // The Index signature makes casting to/from classes or interfaces a pain.
    // Custom types are OK.
    interface StorageObject {
        [key: string]: StorageValue;
    }
    // These have to be interfaces rather than types to avoid a circular
    // definition of StorageValue
    interface StorageArray extends Array<StorageValue> { }
    interface StorageMap extends Map<StorageValue, StorageValue> { }
    interface StorageSet extends Set<StorageValue> { }
    interface Get {
        <T extends StorageObject>(keys?: string | string[] | null): Promise<T>;
        /* <T extends StorageObject>(keys: T): Promise<{[K in keyof T]: T[K]}>; */
        <T extends StorageObject>(keys: T): Promise<T>;
    }
    type StorageArea = {
        get: Get;
        // unsupported: getBytesInUse: (keys: string|string[]|null) => Promise<number>,
        set: (keys: StorageObject) => Promise<void>;
        remove: (keys: string | string[]) => Promise<void>;
        clear: () => Promise<void>;
    };
    type StorageChange = {
        oldValue?: any;
        newValue?: any;
    };
    const sync: StorageArea;
    const local: StorageArea;
    // unsupported: const managed: StorageArea;
    type ChangeDict = { [field: string]: StorageChange };
    type StorageName = "sync" | "local" /* |"managed" */;
    const onChanged: EvListener<(changes: ChangeDict, areaName: StorageName) => void>;
}
declare namespace browser.topSites {
    type MostVisitedURL = {
        title: string;
        url: string;
    };
    function get(): Promise<MostVisitedURL[]>;
}
declare namespace browser.webNavigation {
    type TransitionType = "link" | "auto_subframe" | "form_submit" | "reload";
    // unsupported: | "typed" | "auto_bookmark" | "manual_subframe"
    //              | "generated" | "start_page" | "keyword"
    //              | "keyword_generated";
    type TransitionQualifier =
        | "client_redirect"
        | "server_redirect"
        | "forward_back";
    // unsupported: "from_address_bar";
    function getFrame(details: {
        tabId: number;
        processId: number;
        frameId: number;
    }): Promise<{ errorOccured: boolean; url: string; parentFrameId: number }>;
    function getAllFrames(details: {
        tabId: number;
    }): Promise<{
        errorOccured: boolean;
        processId: number;
        frameId: number;
        parentFrameId: number;
        url: string;
    }[]>;
    interface NavListener<T> {
        addListener: (callback: (arg: T) => void, filter?: {
                url: browser.events.UrlFilter[];
            }) => void;
        removeListener: (callback: (arg: T) => void) => void;
        hasListener: (callback: (arg: T) => void) => boolean;
    }
    type DefaultNavListener = NavListener<{
        tabId: number;
        url: string;
        processId: number;
        frameId: number;
        timeStamp: number;
    }>;
    type TransitionNavListener = NavListener<{
        tabId: number;
        url: string;
        processId: number;
        frameId: number;
        timeStamp: number;
        transitionType: TransitionType;
        transitionQualifiers: TransitionQualifier[];
    }>;
    const onBeforeNavigate: NavListener<{
        tabId: number;
        url: string;
        processId: number;
        frameId: number;
        parentFrameId: number;
        timeStamp: number;
    }>;
    const onCommitted: TransitionNavListener;
    const onCreatedNavigationTarget: NavListener<{
        sourceFrameId: number;
        // Unsupported: sourceProcessId: number,
        sourceTabId: number;
        tabId: number;
        timeStamp: number;
        url: string;
        windowId: number;
    }>;
    const onDOMContentLoaded: DefaultNavListener;
    const onCompleted: DefaultNavListener;
    const onErrorOccurred: DefaultNavListener; // error field unsupported
    const onReferenceFragmentUpdated: TransitionNavListener;
    const onHistoryStateUpdated: TransitionNavListener;
}
declare namespace browser.webRequest {
    type ResourceType = 
        | "main_frame" | "sub_frame" | "stylesheet" | "script" | "image" | "object" | "xmlhttprequest" | "xbl" | "xslt" 
        | "ping" | "beacon" | "xml_dtd" | "font" | "media" | "websocket" | "csp_report" | "imageset" | "web_manifest"
        | "other";
    type RequestFilter = {
        urls: string[];
        types?: ResourceType[];
        tabId?: number;
        windowId?: number;
    };
    type StreamFilter = {
        onstart: (event: any) => void;
        ondata: (event: { data: ArrayBuffer }) => void;
        onstop: (event: any) => void;
        onerror: (event: any) => void;

        close(): void;
        disconnect(): void;
        resume(): void;
        suspend(): void;
        write(data: Uint8Array | ArrayBuffer): void;

        error: string;
        status: "uninitialized" | "transferringdata" | "finishedtransferringdata" | "suspended" | "closed" 
                | "disconnected" | "failed";
    };
    type HttpHeaders = (
        | { name: string; binaryValue: number[]; value?: string }
        | { name: string; value: string; binaryValue?: number[] })[];
    type BlockingResponse = {
        cancel?: boolean;
        redirectUrl?: string;
        requestHeaders?: HttpHeaders;
        responseHeaders?: HttpHeaders;
        // unsupported: authCredentials?: { username: string, password: string },
    };
    type UploadData = {
        bytes?: ArrayBuffer;
        file?: string;
    };
    const MAX_HANDLER_BEHAVIOR_CHANGED_CALLS_PER_10_MINUTES: number;
    function handlerBehaviorChanged(): Promise<void>;
    // TODO: Enforce the return result of the addListener call in the contract
    //       Use an intersection type for all the default properties
    interface ReqListener<T, U> {
        addListener: (
            callback: (arg: T) => void,
            filter: RequestFilter,
            extraInfoSpec?: Array<U>
        ) => BlockingResponse | Promise<BlockingResponse>;
        removeListener: (callback: (arg: T) => void) => void;
        hasListener: (callback: (arg: T) => void) => boolean;
    }
    const onBeforeRequest: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        requestBody?: {
            error?: string;
            formData?: { [key: string]: string[] };
            raw?: UploadData[];
        };
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
    },"blocking" | "requestBody">;
    const onBeforeSendHeaders: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        requestHeaders?: HttpHeaders;
    },"blocking" | "requestHeaders">;
    const onSendHeaders: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        requestHeaders?: HttpHeaders;
    },"requestHeaders">;
    const onHeadersReceived: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        statusLine: string;
        responseHeaders?: HttpHeaders;
        statusCode: number;
    }, "blocking" | "responseHeaders">;
    const onAuthRequired: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        scheme: string;
        realm?: string;
        challenger: { host: string; port: number };
        isProxy: boolean;
        responseHeaders?: HttpHeaders;
        statusLine: string;
        statusCode: number;
    },"blocking" | "responseHeaders">;
    const onResponseStarted: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        ip?: string;
        fromCache: boolean;
        statusLine: string;
        responseHeaders?: HttpHeaders;
        statusCode: number;
    },"responseHeaders">;
    const onBeforeRedirect: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        ip?: string;
        fromCache: boolean;
        statusCode: number;
        redirectUrl: string;
        statusLine: string;
        responseHeaders?: HttpHeaders;
    },"responseHeaders">;
    const onCompleted: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        ip?: string;
        fromCache: boolean;
        statusCode: number;
        statusLine: string;
        responseHeaders?: HttpHeaders;
    },"responseHeaders">;
    const onErrorOccurred: ReqListener<{
        requestId: string;
        url: string;
        method: string;
        frameId: number;
        parentFrameId: number;
        tabId: number;
        type: ResourceType;
        timeStamp: number;
        originUrl: string;
        ip?: string;
        fromCache: boolean;
        error: string;
    },void>;
    function filterResponseData(requestId: string): StreamFilter;
}
declare namespace browser.windows {
    type WindowType = "normal" | "popup" | "panel" | "devtools";
    type WindowState = "normal" | "minimized" | "maximized" | "fullscreen"| "docked";
    type Window = {
        id?: number;
        focused: boolean;
        top?: number;
        left?: number;
        width?: number;
        height?: number;
        tabs?: ChromeTab[];
        incognito: boolean;
        type?: WindowType;
        state?: WindowState;
        alwaysOnTop: boolean;
        sessionId?: string;
    };
    type CreateType = "normal" | "popup" | "panel" | "detached_panel";
    const WINDOW_ID_NONE: number;
    const WINDOW_ID_CURRENT: number;
    function get(windowId: number, getInfo?: {
                                                populate?: boolean;
                                                windowTypes?: WindowType[];
                                            }): Promise<browser.windows.Window>;
    function getCurrent(getInfo?: {
        populate?: boolean;
        windowTypes?: WindowType[];
    }): Promise<browser.windows.Window>;
    function getLastFocused(getInfo?: {
        populate?: boolean;
        windowTypes?: WindowType[];
    }): Promise<browser.windows.Window>;
    function getAll(getInfo?: {
        populate?: boolean;
        windowTypes?: WindowType[];
    }): Promise<browser.windows.Window[]>;
    // TODO: url and tabId should be exclusive
    function create(createData?: {
        url?: string | string[];
        tabId?: number;
        left?: number;
        top?: number;
        width?: number;
        height?: number;
        // unsupported: focused?: boolean,
        incognito?: boolean;
        type?: CreateType;
        state?: WindowState;
    }): Promise<browser.windows.Window>;
    function update(windowId: number, updateInfo: {
            left?: number;
            top?: number;
            width?: number;
            height?: number;
            focused?: boolean;
            drawAttention?: boolean;
            state?: WindowState;
        }): Promise<browser.windows.Window>;
    function remove(windowId: number): Promise<void>;
    const onCreated: Listener<browser.windows.Window>;
    const onRemoved: Listener<number>;
    const onFocusChanged: Listener<number>;
}
declare namespace browser.theme {
    type Theme = {
        images: ThemeImages;
        colors: ThemeColors;
        properties?: ThemeProperties;
    };
    type ThemeImages = {
        headerURL: string;
        theme_frame?: string;
        additional_backgrounds?: string[];
    };
    type ThemeColors = {
        accentcolor: string;
        textcolor: string;
        frame?: [number, number, number];
        tab_text?: [number, number, number];
        toolbar?: string;
        toolbar_text?: string;
        toolbar_field?: string;
        toolbar_field_text?: string;
    };
    type ThemeProperties = {
        additional_backgrounds_alignment: Alignment[];
        additional_backgrounds_tiling: Tiling[];
    };
    type Alignment = | "bottom" | "center" | "left" | "right" | "top" | "center bottom" | "center center" | "center top" 
                     | "left bottom" | "left center" | "left top" | "right bottom" | "right center"| "right top";
    type Tiling = "no-repeat" | "repeat" | "repeat-x" | "repeat-y";
    function getCurrent(): Promise<Theme>;
    function getCurrent(windowId: number): Promise<Theme>;
    function update(theme: Theme): Promise<void>;
    function update(windowId: number, theme: Theme): Promise<void>;
    function reset(): Promise<void>;
    function reset(windowId: number): Promise<void>;
}
//</editor-fold>
//</editor-fold>
